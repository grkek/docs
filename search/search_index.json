{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Runcobo is a general purpose framework built on Crystal. Commands \u00b6 runcobo [ <commands>... ] [ <arguments>... ] Commands: routes - Print all routes of the app. version - Print the current version of the runcobo. help - Print usage synopsis. Options: -h, --help Print usage synopsis. -v, --version Print the current version of the runcobo. Project Architecture \u00b6 lib/ # Library src/ main.cr # Entry file actions/ # Actions Directory ... assets/ # Assets Directory views/ # Views Directory layouts/ # Layouts directory ... models/ # Models Directory ... shards.yml # The packages congfiuration file shards.lock # The lock file for packages congfiuration file Keep in this architecture to use layouts macro, render macro. Design Architecture \u00b6 MVC (Model-View-Controller) Design Principles \u00b6 Simple Design must be simple, both in implementation and interface. Intuitive Design must be intuitive. Consistent Design must be consistent.","title":"Introduction"},{"location":"#introduction","text":"Runcobo is a general purpose framework built on Crystal.","title":"Introduction"},{"location":"#commands","text":"runcobo [ <commands>... ] [ <arguments>... ] Commands: routes - Print all routes of the app. version - Print the current version of the runcobo. help - Print usage synopsis. Options: -h, --help Print usage synopsis. -v, --version Print the current version of the runcobo.","title":"Commands"},{"location":"#project-architecture","text":"lib/ # Library src/ main.cr # Entry file actions/ # Actions Directory ... assets/ # Assets Directory views/ # Views Directory layouts/ # Layouts directory ... models/ # Models Directory ... shards.yml # The packages congfiuration file shards.lock # The lock file for packages congfiuration file Keep in this architecture to use layouts macro, render macro.","title":"Project Architecture"},{"location":"#design-architecture","text":"MVC (Model-View-Controller)","title":"Design Architecture"},{"location":"#design-principles","text":"Simple Design must be simple, both in implementation and interface. Intuitive Design must be intuitive. Consistent Design must be consistent.","title":"Design Principles"},{"location":"action/","text":"Action \u00b6 Runcobo use one action one file. Before Filter \u00b6 class BeforeExample < BaseAction before required_login def required_login Runcobo :: Log . info { \"Required Login\" } end get \"/before_example\" call do render_plain \"Hello World!\" end end After Filter \u00b6 class AfterExample < BaseAction after log_params def log_params Runcobo :: Log . info { \" #{ params } \" } end get \"/after_example\" call do render_plain \"Hello World!\" end end Skip Filter \u00b6 class BaseAction before required_login def required_login Runcobo :: Log . info { \"Required Login\" } end end class SkipExample < BaseAction skip required_login get \"/skip_example\" call do render_plain \"Hello World!\" end end","title":"Overview"},{"location":"action/#action","text":"Runcobo use one action one file.","title":"Action"},{"location":"action/#before-filter","text":"class BeforeExample < BaseAction before required_login def required_login Runcobo :: Log . info { \"Required Login\" } end get \"/before_example\" call do render_plain \"Hello World!\" end end","title":"Before Filter"},{"location":"action/#after-filter","text":"class AfterExample < BaseAction after log_params def log_params Runcobo :: Log . info { \" #{ params } \" } end get \"/after_example\" call do render_plain \"Hello World!\" end end","title":"After Filter"},{"location":"action/#skip-filter","text":"class BaseAction before required_login def required_login Runcobo :: Log . info { \"Required Login\" } end end class SkipExample < BaseAction skip required_login get \"/skip_example\" call do render_plain \"Hello World!\" end end","title":"Skip Filter"},{"location":"getting_started/","text":"Getting Started \u00b6 1.Init a Crystal project. crystal init app demo && cd demo 2.Add the dependency to your shard.yml and run shards install . dependencies : runcobo : github : runcobo/runcobo 3.Write down the following code in src/demo.cr . require \"runcobo\" class Api::V1:: Add < BaseAction get \"/api/v1/add\" query NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end Runcobo . start 4.Run server. crystal src/demo.cr 5.Send request. curl \"http://0.0.0.0:3000/api/v1/add?a=1&b=2\" 6.Auto restart server. # Use nodemon to watch file changed and auto restart server. sudo npm install -g nodemon nodemon -e \"cr,water,jbuilder,yml\" --exec \"crystal run\" src/demo.cr","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"1.Init a Crystal project. crystal init app demo && cd demo 2.Add the dependency to your shard.yml and run shards install . dependencies : runcobo : github : runcobo/runcobo 3.Write down the following code in src/demo.cr . require \"runcobo\" class Api::V1:: Add < BaseAction get \"/api/v1/add\" query NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end Runcobo . start 4.Run server. crystal src/demo.cr 5.Send request. curl \"http://0.0.0.0:3000/api/v1/add?a=1&b=2\" 6.Auto restart server. # Use nodemon to watch file changed and auto restart server. sudo npm install -g nodemon nodemon -e \"cr,water,jbuilder,yml\" --exec \"crystal run\" src/demo.cr","title":"Getting Started"},{"location":"html/","text":"Render HTML \u00b6 src/controllers/books/index.cr class Books:: Index < BaseAction get \"/books\" call do books = Book . all render_water \"books/index\" end end src/views/books/index.water table %| class = \"table table-hover\" | { thead { tr { th \"ID\" th \"Author\" th \"Name\" th \"Published At\" } } tbody { books . each do | book | tr { td book . id td book . author td book . name td book . published_at } end } } Then, output a HTML string. <table class= \"table table-hover\" > <thead> <tr> <th>ID</th> <th>Author</th> <th>Name</th> <th>Published At</th> </tr> </thead> <tbody> <tr> <td> 1 </td> <td>David</td> <td>Crystal Programming</td> <td> 2020-08-02 14 : 07 : 41 + 08 : 00 </td> </tr> </tbody> </table> Render Partial \u00b6 src/views/books/index.jbuilder {{ read_file ( \"src/views/books/table.water\" ) . id }} src/views/books/table.water table %| class = \"table table-hover\" | { thead { tr { th \"ID\" th \"Author\" th \"Name\" th \"Published At\" } } tbody { books . each do | book | tr { td book . id td book . author td book . name td book . published_at } end } }","title":"HTML"},{"location":"html/#render-html","text":"src/controllers/books/index.cr class Books:: Index < BaseAction get \"/books\" call do books = Book . all render_water \"books/index\" end end src/views/books/index.water table %| class = \"table table-hover\" | { thead { tr { th \"ID\" th \"Author\" th \"Name\" th \"Published At\" } } tbody { books . each do | book | tr { td book . id td book . author td book . name td book . published_at } end } } Then, output a HTML string. <table class= \"table table-hover\" > <thead> <tr> <th>ID</th> <th>Author</th> <th>Name</th> <th>Published At</th> </tr> </thead> <tbody> <tr> <td> 1 </td> <td>David</td> <td>Crystal Programming</td> <td> 2020-08-02 14 : 07 : 41 + 08 : 00 </td> </tr> </tbody> </table>","title":"Render HTML"},{"location":"html/#render-partial","text":"src/views/books/index.jbuilder {{ read_file ( \"src/views/books/table.water\" ) . id }} src/views/books/table.water table %| class = \"table table-hover\" | { thead { tr { th \"ID\" th \"Author\" th \"Name\" th \"Published At\" } } tbody { books . each do | book | tr { td book . id td book . author td book . name td book . published_at } end } }","title":"Render Partial"},{"location":"installation/","text":"Installation \u00b6 Install Crystal \u00b6 Crystal is a language for humans and computers. Crystal is a type safe, compiled language inspired by the simplicity of Ruby. Type safety means more errors are caught by the compiler during development, so you can be more confident about your code working in production. See https://crystal-lang.org/install/ to install Crystal. Install Runcobo \u00b6 You can install Runcobo from sources. Other installations are working on. curl -L https://github.com/runcobo/runcobo/archive/stable.zip --output runcobo.zip unzip runcobo.zip cd runcobo-stable/ sudo make install runcobo -v","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#install-crystal","text":"Crystal is a language for humans and computers. Crystal is a type safe, compiled language inspired by the simplicity of Ruby. Type safety means more errors are caught by the compiler during development, so you can be more confident about your code working in production. See https://crystal-lang.org/install/ to install Crystal.","title":"Install Crystal"},{"location":"installation/#install-runcobo","text":"You can install Runcobo from sources. Other installations are working on. curl -L https://github.com/runcobo/runcobo/archive/stable.zip --output runcobo.zip unzip runcobo.zip cd runcobo-stable/ sudo make install runcobo -v","title":"Install Runcobo"},{"location":"json/","text":"Render JSON \u00b6 src/controllers/books/index.cr class Books:: Index < BaseAction get \"/books\" call do books = Book . all render_jbuilder \"books/index\" end end src/views/books/index.jbuilder json . array! \"books\" , books do | json , book | json . book_id book . id json . author book . author json . name book . name json . published_at book . published_at end Then, output a JSON string. { \"books\" : [{ \"book_id\" : 1 , \"author\" : \"David\" , \"name\" : \"Crystal Programming\" , \"published_at\" : \"2020-08-08T20:00:00+00:00\" }] } Render Partial \u00b6 src/views/books/index.jbuilder json . array! \"books\" , books do | json , book | {{ read_file ( \"src/views/books/_base_book.jbuilder\" ) . id }} end src/views/books/_base_book.jbuilder json . book_id book . id json . author book . author json . name book . name json . published_at book . published_at","title":"JSON"},{"location":"json/#render-json","text":"src/controllers/books/index.cr class Books:: Index < BaseAction get \"/books\" call do books = Book . all render_jbuilder \"books/index\" end end src/views/books/index.jbuilder json . array! \"books\" , books do | json , book | json . book_id book . id json . author book . author json . name book . name json . published_at book . published_at end Then, output a JSON string. { \"books\" : [{ \"book_id\" : 1 , \"author\" : \"David\" , \"name\" : \"Crystal Programming\" , \"published_at\" : \"2020-08-08T20:00:00+00:00\" }] }","title":"Render JSON"},{"location":"json/#render-partial","text":"src/views/books/index.jbuilder json . array! \"books\" , books do | json , book | {{ read_file ( \"src/views/books/_base_book.jbuilder\" ) . id }} end src/views/books/_base_book.jbuilder json . book_id book . id json . author book . author json . name book . name json . published_at book . published_at","title":"Render Partial"},{"location":"model/","text":"Model \u00b6 Here is a list of ORM from awesome-crystal avram - A database wrapper for reading, writing, and migrating Postgres databases. (Only Postgres) clear - ORM specialized to PostgreSQL only but with advanced features (Only Postgres) crecto - Database wrapper, based on Ecto granite - ORM for Postgres, Mysql, Sqlite jennifer.cr - Active Record pattern implementation with flexible query chainable builder and migration system ohm-crystal - Object-hash mapping library for Redis (Only Redis) onyx-sql - DB-agnostic SQL ORM with beautiful DSL and type-safe Query builder rethinkdb-orm - ORM for RethinkDB / RebirthDB (Only RethinkDB / RebirthDB) stal-crystal - Set algebra solver for Redis Runcobo prefers to use jennifer.cr , you can check its docs and api .","title":"Overview"},{"location":"model/#model","text":"Here is a list of ORM from awesome-crystal avram - A database wrapper for reading, writing, and migrating Postgres databases. (Only Postgres) clear - ORM specialized to PostgreSQL only but with advanced features (Only Postgres) crecto - Database wrapper, based on Ecto granite - ORM for Postgres, Mysql, Sqlite jennifer.cr - Active Record pattern implementation with flexible query chainable builder and migration system ohm-crystal - Object-hash mapping library for Redis (Only Redis) onyx-sql - DB-agnostic SQL ORM with beautiful DSL and type-safe Query builder rethinkdb-orm - ORM for RethinkDB / RebirthDB (Only RethinkDB / RebirthDB) stal-crystal - Set algebra solver for Redis Runcobo prefers to use jennifer.cr , you can check its docs and api .","title":"Model"},{"location":"params/","text":"Params \u00b6 Type-safe Params \u00b6 An old Chinese proverb says, \"If something is important, then repeat it three times\". So, Params in Runcobo are type-safe. Params in Runcobo are type-safe. Params in Runcobo are type-safe. Three Steps To Use Params \u00b6 First, declare what params you expect and what type you expect by following methods: url , query , form and json . Next, Runcobo parses request and wraps params to a local variable called params . Third, use params variable to get or set request params. Url Params \u00b6 class UrlExample < BaseAction get \"/url_example/:a/:b\" url NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end Query Params \u00b6 class QueryExample < BaseAction get \"/query_example\" query NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end Form Params \u00b6 class FormExample < BaseAction post \"/form_example\" form NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end JSON Params \u00b6 class JsonExample < BaseAction post \"/json_example\" json NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end Params Merge Order \u00b6 You can declare various kinds of params in a action. If params are in same key, they will be merged in following order: Query Params < Form Params < JSON Params < Url Params","title":"Params"},{"location":"params/#params","text":"","title":"Params"},{"location":"params/#type-safe-params","text":"An old Chinese proverb says, \"If something is important, then repeat it three times\". So, Params in Runcobo are type-safe. Params in Runcobo are type-safe. Params in Runcobo are type-safe.","title":"Type-safe Params"},{"location":"params/#three-steps-to-use-params","text":"First, declare what params you expect and what type you expect by following methods: url , query , form and json . Next, Runcobo parses request and wraps params to a local variable called params . Third, use params variable to get or set request params.","title":"Three Steps To Use Params"},{"location":"params/#url-params","text":"class UrlExample < BaseAction get \"/url_example/:a/:b\" url NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end","title":"Url Params"},{"location":"params/#query-params","text":"class QueryExample < BaseAction get \"/query_example\" query NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end","title":"Query Params"},{"location":"params/#form-params","text":"class FormExample < BaseAction post \"/form_example\" form NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end","title":"Form Params"},{"location":"params/#json-params","text":"class JsonExample < BaseAction post \"/json_example\" json NamedTuple ( a : Int32 , b : Int32 ) call do sum = params [ :a ] + params [ :b ] render_plain sum . to_s end end","title":"JSON Params"},{"location":"params/#params-merge-order","text":"You can declare various kinds of params in a action. If params are in same key, they will be merged in following order: Query Params < Form Params < JSON Params < Url Params","title":"Params Merge Order"},{"location":"render/","text":"Render \u00b6 Render HTML \u00b6 class WaterExample < BaseAction get \"/water_example\" call do render_water \"examples/index\" end end Render Plain \u00b6 class PlainExample < BaseAction get \"/plain_example\" call do render_plain \"Hello World!\" end end Render Body \u00b6 class BodyExample < BaseAction get \"/body_example\" call do render_body \"Hello World!\" end end Render JSON \u00b6 class JbuilderExample < BaseAction get \"/jbuilder_example\" call do render_jbuilder \"examples/index\" end end","title":"Render"},{"location":"render/#render","text":"","title":"Render"},{"location":"render/#render-html","text":"class WaterExample < BaseAction get \"/water_example\" call do render_water \"examples/index\" end end","title":"Render HTML"},{"location":"render/#render-plain","text":"class PlainExample < BaseAction get \"/plain_example\" call do render_plain \"Hello World!\" end end","title":"Render Plain"},{"location":"render/#render-body","text":"class BodyExample < BaseAction get \"/body_example\" call do render_body \"Hello World!\" end end","title":"Render Body"},{"location":"render/#render-json","text":"class JbuilderExample < BaseAction get \"/jbuilder_example\" call do render_jbuilder \"examples/index\" end end","title":"Render JSON"},{"location":"route/","text":"Route \u00b6 Runcobo declares routes in every Actions. If you access the route, it will run into related Action. In this way, you can know the routes of current Action quickly. You can declare RESTful routes as you want or not. In my personal view, RESTful is too abstact when you were far way from a CRUD system like Backend Management System. When writing API, I believe urls should be named like functions, not objects or resources. When writing a Backend Management System, enjoy RESTful. Routes Declaration \u00b6 Runcobo declares routes by following methods: get , post , put , patch , delete , options , head . An Action can bind to one or more routes. class Example < BaseAction get \"/books\" get \"/books/:id\" post \"/books\" put \"/books/:id\" patch \"/books/:id\" delete \"/books/:id\" options \"/books/:id\" head \"/books/:id\" call do render_plain \"Hello World\" end end URL Params \u00b6 URL Params can be declared in the route like /add/:apple_count/:banana_count . And then you should use url method to declare the type of URL params. class Example < BaseAction get \"/add/:apple_count/:banana_count\" url NamedTuple ( apple_count : Int32 , banana_count : Int32 ) call do sum = params [ :apple_count ] + params [ :banana_count ] render_plain sum . to_s end end Custom HTTP method \u00b6 If you need a route with custom HTTP method, such as LINK , UNLINK , FIND or PURGE , then you can use route method to declare it. class Example < BaseAction route \"LINK\" , \"/books/:id\" call do render_plain \"Hello World\" end end","title":"Route"},{"location":"route/#route","text":"Runcobo declares routes in every Actions. If you access the route, it will run into related Action. In this way, you can know the routes of current Action quickly. You can declare RESTful routes as you want or not. In my personal view, RESTful is too abstact when you were far way from a CRUD system like Backend Management System. When writing API, I believe urls should be named like functions, not objects or resources. When writing a Backend Management System, enjoy RESTful.","title":"Route"},{"location":"route/#routes-declaration","text":"Runcobo declares routes by following methods: get , post , put , patch , delete , options , head . An Action can bind to one or more routes. class Example < BaseAction get \"/books\" get \"/books/:id\" post \"/books\" put \"/books/:id\" patch \"/books/:id\" delete \"/books/:id\" options \"/books/:id\" head \"/books/:id\" call do render_plain \"Hello World\" end end","title":"Routes Declaration"},{"location":"route/#url-params","text":"URL Params can be declared in the route like /add/:apple_count/:banana_count . And then you should use url method to declare the type of URL params. class Example < BaseAction get \"/add/:apple_count/:banana_count\" url NamedTuple ( apple_count : Int32 , banana_count : Int32 ) call do sum = params [ :apple_count ] + params [ :banana_count ] render_plain sum . to_s end end","title":"URL Params"},{"location":"route/#custom-http-method","text":"If you need a route with custom HTTP method, such as LINK , UNLINK , FIND or PURGE , then you can use route method to declare it. class Example < BaseAction route \"LINK\" , \"/books/:id\" call do render_plain \"Hello World\" end end","title":"Custom HTTP method"},{"location":"view/","text":"View \u00b6 Runcobo renders JSON by Jbuilder , renders HTML by Water . Jbuilder is a template engine designed for json using plain Crystal. Water is a template engine designed for html using plain Crystal. Data transfer \u00b6 All methods or variables defined in the action are available in the views. This is because the views are compiled in the same scope as the action. Layout \u00b6 You can override the default layout conventions in your actions by using the layout declaration. For example: class BaseAction layout \"application\" #... end Partial \u00b6 Runcobo renders partial view by build-in read_file macro. There's no magic about partial view. For example, src/views/books/index.jbuilder json . array! \"books\" , books do | json , book | {{ read_file ( \"src/views/books/_base_book.jbuilder\" ) . id }} end src/views/books/_base_book.jbuilder json . book_id book . id json . author book . author json . name book . name json . published_at book . published_at","title":"Overview"},{"location":"view/#view","text":"Runcobo renders JSON by Jbuilder , renders HTML by Water . Jbuilder is a template engine designed for json using plain Crystal. Water is a template engine designed for html using plain Crystal.","title":"View"},{"location":"view/#data-transfer","text":"All methods or variables defined in the action are available in the views. This is because the views are compiled in the same scope as the action.","title":"Data transfer"},{"location":"view/#layout","text":"You can override the default layout conventions in your actions by using the layout declaration. For example: class BaseAction layout \"application\" #... end","title":"Layout"},{"location":"view/#partial","text":"Runcobo renders partial view by build-in read_file macro. There's no magic about partial view. For example, src/views/books/index.jbuilder json . array! \"books\" , books do | json , book | {{ read_file ( \"src/views/books/_base_book.jbuilder\" ) . id }} end src/views/books/_base_book.jbuilder json . book_id book . id json . author book . author json . name book . name json . published_at book . published_at","title":"Partial"}]}